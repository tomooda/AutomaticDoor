module AutomaticDoorimports    from Time all,    from Sensor all,    from Motor allexports alldefinitionsvalues    OPEN_DURATION : Time`Second = 1;state AutomaticDoor of    closeTime : [Time`Second]init s == s = mk_AutomaticDoor(nil)endoperations    tick : () ==> ()    tick() ==        let now = Time`now()        in            (if Sensor`detect() then Motor`open();            if                closeTime = nil            then                (if Motor`isOpen() then closeTime := now + OPEN_DURATION)            else                (if                    now > closeTime                then                    (closeTime := nil;                    Motor`close()));            Motor`tick());end AutomaticDoormodule Motorimports from Time allexports alldefinitionstypes    Command = <open> | <close> | <halt>;        Position = real inv p == 0.0 <= p and p <= 1.0;        PositionPerSecond = real;values    SPEED : PositionPerSecond = 0.2;        OPEN_POSITION : Position = 1.0;        CLOSED_POSITION : Position = 0.0;state Motor of    command : Command    position : Position    lastTick : Time`Secondinit s == s = mk_Motor(<halt>, OPEN_POSITION, time  * Time`NANO)endoperations    open : () ==> ()    open() == command := <open>;        close : () ==> ()    close() == command := <close>;        halt : () ==> ()    halt() == command := <halt>;        pure getPosition : () ==> Position    getPosition() == return position;        setPosition : Position ==> ()    setPosition(p) == position := p;        pure isOpening : () ==> bool    isOpening() == return command = <open>;        pure isClosing : () ==> bool    isClosing() == return command = <close>;        pure isHalted : () ==> bool    isHalted() == return command = <halt>;        tick : () ==> ()    tick() ==        (dcl            now:Time`Second := Time`now(),            delta_t:Time`Second := now - lastTick;        lastTick := now;        cases command:            <open> ->                (position := min(position + SPEED  * delta_t, OPEN_POSITION);                if position = OPEN_POSITION then (command := <halt>)),            <close> ->                (position := max(position - SPEED  * delta_t, CLOSED_POSITION);                if position = CLOSED_POSITION then command := <halt>),            others -> skip            end);functions    min : real * real -> real    min(x, y) == if x <= y then x else y;        max : real * real -> real    max(x, y) == if x >= y then x else y;end Motormodule Sensorexports alldefinitionsstate Sensor of    sensor : boolinit s == s = mk_Sensor(false)endoperations    detect : () ==> bool    detect() == return sensor;        setSensor : bool ==> ()    setSensor(s) == sensor := s;end Sensormodule Timeexports alldefinitionstypes    Second = real inv t == t >= 0;values    NANO : real = 1.0e-9;operations    pure now : () ==> Second    now() == return time  * NANO;end Timemodule UnitTestingexports alldefinitionstypes    AssertFailure :: msg : seq of char;        AssertEqualsFailure :: actual : ? expected : ? msg : seq of char;operations    assert : bool * seq of char ==> ()    assert(b, msg) == if not b then exit mk_AssertFailure(msg);        assertEquals : ? * ? * seq of char ==> ()    assertEquals(actual, expected, msg) ==        if            actual <> expected        then            exit mk_AssertEqualsFailure(actual, expected, msg);        assertApproxEquals : real * real * real * seq of char ==> ()    assertApproxEquals(actual, expected, accuracy, msg) ==        if            abs (actual - expected) > accuracy        then            exit mk_AssertEqualsFailure(actual, expected, msg);end UnitTestingmodule MotorTestimports    from Motor all,    from UnitTesting        operations            assert: bool * seq of char ==> () renamed assert;            assertEquals: ? * ? * seq of char ==> () renamed assertEquals;            assertApproxEquals: real * real * real * seq of char ==> ()                renamed assertApproxEquals;exports alldefinitionsoperations    test_open : () ==> ()    test_open() ==        (dcl position:real;        Motor`setPosition(Motor`CLOSED_POSITION);        Motor`open();        assert(Motor`isOpening(), "must be opening");        position := Motor`getPosition();        Motor`tick();        assert(Motor`getPosition() > position, "Position must increase");        while Motor`isOpening() do Motor`tick();        assertEquals(Motor`getPosition(), Motor`OPEN_POSITION, "open");        assert(Motor`isHalted(), "must be halted"));        test_close : () ==> ()    test_close() ==        (dcl position:real;        Motor`setPosition(Motor`OPEN_POSITION);        Motor`close();        assert(Motor`isClosing(), "must be closing");        position := Motor`getPosition();        Motor`tick();        assert(Motor`getPosition() < position, "Position must decrease");        while Motor`isClosing() do Motor`tick();        assertEquals(Motor`getPosition(), Motor`CLOSED_POSITION, "closed");        assert(Motor`isHalted(), "must be halted"));end MotorTestmodule SensorTestimports    from Sensor all,    from UnitTesting        operations            assert: bool * seq of char ==> () renamed assert;            assertEquals: ? * ? * seq of char ==> () renamed assertEquals;            assertApproxEquals: real * real * real * seq of char ==> ()                renamed assertApproxEquals;exports alldefinitionsoperations    test_detect : () ==> ()    test_detect() ==        (Sensor`setSensor(true);        assert(Sensor`detect(), "must detect");        Sensor`setSensor(false);        assert(not Sensor`detect(), "must not detect"));end SensorTest